/**
 * 
 */
package org.tonoplace.mcmods.timetracker.data;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Date;

import org.tonoplace.mcmods.timetracker.TimeTrackerMod;

import org.apache.commons.codec.binary.*;

import net.minecraftforge.common.config.Configuration;

/**
 * @author BlackTachyon
 * Tracks a given statistic.
 */
public class TimeStatistic implements Serializable {
   private StatisticCategory category;
   private String playerName;
   private String statName;
   private long baseTime;
   private Date timeStamp;
   private boolean paused;
   private transient long lastSeconds;
   private transient String lastTime;
   //net.minecraftforge.event
   public TimeStatistic()
   {
      category = StatisticCategory.Global;
      playerName = "";
      statName = "";
      reset();
   }
   
   public TimeStatistic(StatisticCategory category, String playerName, String statName) {
      this.category = category;
      this.playerName = playerName==null ? "" : playerName;
      this.statName = statName==null ? "" : statName;
      reset();
   }
   
   public String GetName() {
      if(category==StatisticCategory.Global) {
         return statName;
      } else {
         return playerName + "." + statName;
      }
   }
   
   public synchronized void normalizeTime(Date normalizeTo) {
      if(normalizeTo==null)
         normalizeTo = new Date();
      if(!paused) {
         long sinceLastTimeStamp = normalizeTo.getTime() - timeStamp.getTime();
         baseTime += sinceLastTimeStamp;
      }
      timeStamp = normalizeTo;
   }
   
   public synchronized void reset() {
      baseTime = 0;
      timeStamp = new Date();
      paused = false;
      lastSeconds = -1;
      lastTime = "N/A";
   }
   
   public void pause() {
      paused = true;
   }
   
   public void unpause() {
      paused = false;
   }
   
   public String GetTime()
   {
      long totalSeconds = GetElapsedTime(new Date()) / 1000;
      // Skip additional calculation and formating if no measurable time has passed...  
      if (totalSeconds > lastSeconds) {
         lastSeconds  = totalSeconds;
         long seconds = totalSeconds % 60;
         long minutes = totalSeconds / 60 % 60;
         long hours   = totalSeconds / 3600 % 24;
         long days    = totalSeconds / 3600 / 24;
         lastTime     = String.format("%01dD %02d:%02d:%02d", days, hours, minutes, seconds);
      }
      return lastTime;
   }
  
   @Override
   public String toString() {
      return category + "." + GetName() + ": " + GetTime();
   }
   
   @Override
   public boolean equals(Object o) {
      TimeStatistic ts = (o instanceof TimeStatistic) ? (TimeStatistic)o : null;
      if(ts==null) return false;
      if(this==ts) return true;
      if(category==ts.category &&
         paused==ts.paused &&
         playerName.equals(ts.playerName) &&
         statName.equals(ts.statName))
      {
         Date timeCheck = new Date();
         return GetElapsedTime(timeCheck) == ts.GetElapsedTime(timeCheck);
      }
      return false;
   }
   
   @Override 
   public int hashCode() {
      return Arrays.hashCode(new Object[] { category, playerName, statName, paused } );
   }
   
   private synchronized long GetElapsedTime(Date since) {
      if(since==null)
         since = new Date();
      if(paused)
         return baseTime;
      else
         return baseTime + since.getTime() - timeStamp.getTime();
   }

   /**
    * @param config
    */
   public void load(Configuration config) {
      // TODO Auto-generated method stub
      String cat = category.toString();
      String baseKey = GetName();
      ByteArrayOutputStream baos = null;
      TimeStatistic loaded = null;
      try {
         baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = null;
         try {
            oos = new ObjectOutputStream(baos);
            oos.writeObject(this);
            oos.flush();
            oos.close();
            baos.flush();
            byte[] thisData = baos.toByteArray();
            //String serializedString = Base64.encode(thisData);
            String fromConfig = config.getString(baseKey, cat, serializedString);
            //byte[] otherData = Base64.decode(fromConfig);
            ByteArrayInputStream bais = new ByteArrayInputStream(otherData);
            
         } catch(Exception ie) {
            TimeTrackerMod.logger.error("Error loading config for: " + this, e);
         } finally {
            if(oos!=null) {
               try {
                  oos.close();
               } catch(Exception e) {
                  TimeTrackerMod.logger.error("Error loading config for: " + this, e);
                  throw e;
               }
               oos = null;
            }
         }
               
         
      } catch (Exception e) {
         TimeTrackerMod.logger.error("Error loading config for: " + this, e);
      } finally {
         if(baos!=null) {
            try {
               baos.close();
            } catch (IOException e) {
               TimeTrackerMod.logger.error("Unable to close the ByteArrayOutputStream...",e);
            }
            baos = null;
         }
      }
      
   }
   
   private String ConvertToSerializedString() {
      String result = null;
      ByteArrayOutputStream baos = null;
      Exception caught = null;
      try {
         baos = new ByteArrayOutputStream();
         fillBufferWithSerializedData(baos);
         baos.flush();
         baos.close();
         byte[] serializedData = baos.toByteArray();
         result = Base64.encodeBase64String(serializedData);
      } catch (Exception baosException) {
         TimeTrackerMod.logger.error("Error converting to serialized string.", baosException);
         caught = baosException;
      } finally {
         if(baos!=null) {
            try {
               baos.close();
               baos.reset();
               baos = null;
            } catch (Exception baosCloseException) {
               TimeTrackerMod.logger.error("Error closing the BAOS while serializing the string...", baosCloseException);
               if(caught==null)
                  caught = baosCloseException;
            }
         }
      }
      if(caught!=null)
         throw caught;
      return result;
   }
   
   private void fillBufferWithSerializedData(ByteArrayOutputStream baos) throws Exception {
      ObjectOutputStream oos = null;
      Exception caught = null;
      try {
         oos = new ObjectOutputStream(baos);
         oos.writeObject(this);
         oos.flush();
         oos.close();
      } catch (Exception oosException) {
         TimeTrackerMod.logger.error("Error serializaing out data.", oosException);
         caught = oosException;
      }
      finally {
         if(oos!=null) {
            try {
               oos.close();
               oos = null;
            } catch (Exception oosCloseException) {
               TimeTrackerMod.logger.error("Error closing the OOS while serializing the data...", oosCloseException);
               if(caught==null)
                  caught = oosCloseException;
            }
         }
      }
      if(caught!=null)
         throw caught;
   }
   
   private static TimeStatistic DeserializeString(String serializedString) {
      byte[] serializedData = Base64.decodeBase64(serializedString);
      TimeStatistic returnValue = null;
      ByteArrayInputStream bais = null;
      try {
         bais = new ByteArrayInputStream(bais);
         
      } catch (Exception e)
   }
   
   
}
